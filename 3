#!/bin/bash

# Функция для ожидания завершения задачи
wait_for_status() {
    local object_type=$1
    local object_id=$2
    local desired_status=$3
    local current_status

    while true; do
        current_status=$(openstack $object_type show $object_id -f value -c status)
        if [ "$current_status" = "$desired_status" ]; then
            break
        elif [ "$current_status" = "error" ]; then
            echo "Error: $object_type $object_id is in error state"
            return 1
        fi
        sleep 10
    done
}

# Функция для создания резервной копии одного volume
backup_volume() {
    local volume_id=$1
    local backup_dir=$2

    # Генерация уникальных имен
    local timestamp=$(date +%Y%m%d%H%M%S)
    local snapshot_name="snapshot_${volume_id}_${timestamp}"
    local clone_volume_name="clone_${volume_id}_${timestamp}"
    local image_name="image_${volume_id}_${timestamp}"
    local backup_name="backup_${volume_id}_${timestamp}.qcow2"

    echo "Starting backup process for volume $volume_id"

    # 1. Создание снимка volume
    openstack volume snapshot create --volume $volume_id --force $snapshot_name
    wait_for_status "volume snapshot" $snapshot_name "available" || return 1

    # 2. Создание клона volume из снимка
    openstack volume create --snapshot $snapshot_name $clone_volume_name
    wait_for_status "volume" $clone_volume_name "available" || return 1

    # 3. Создание образа из клона volume
    openstack image create --volume $clone_volume_name $image_name
    wait_for_status "image" $image_name "active" || return 1

    # 4. Сохранение образа в файл
    openstack image save --file $backup_dir/$backup_name $image_name

    # Ожидание завершения сохранения файла
    while [ ! -f $backup_dir/$backup_name ] || [ "$(lsof $backup_dir/$backup_name)" ]; do
        sleep 10
    done

    # 5. Удаление образа
    openstack image delete $image_name

    # 6. Удаление клона volume
    openstack volume delete $clone_volume_name

    # 7. Удаление снимка
    openstack volume snapshot delete $snapshot_name

    echo "Backup completed for volume $volume_id: $backup_dir/$backup_name"
}

# Определение групп volume-ов и их директорий для бэкапа
declare -A volume_groups
volume_groups["/data/1/"]="abcde-12345 abcde-12345-1"
volume_groups["/data/2/"]="abcde-23456 abcde-23456-1"
volume_groups["/data/3/"]="abcde-34567 abcde-34567-1"

# Цикл по группам
for backup_dir in "${!volume_groups[@]}"; do
    echo "Processing group for directory: $backup_dir"
    
    # Создание директории для бэкапов, если она не существует
    mkdir -p "$backup_dir"
    
    # Разделение строки volume_ids на массив
    IFS=' ' read -ra volume_ids <<< "${volume_groups[$backup_dir]}"
    
    # Цикл по volume_ids в текущей группе
    for volume_id in "${volume_ids[@]}"; do
        if backup_volume "$volume_id" "$backup_dir"; then
            echo "Backup process successful for volume $volume_id"
        else
            echo "Backup process failed for volume $volume_id"
        fi
    done
done

echo "All backup processes completed"
